#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sat Sep 29 13:21:54 2018

@author: tianxiang

Q&A:
1. N*M or M*N
"""
import numpy as np
import scipy as sp
import scipy.stats as st

norminv = st.distributions.norm.ppf
norm = st.distributions.norm.cdf
import numpy.linalg
from numpy import exp, sqrt, maximum, mean, std, log, cumsum
from numpy.random import randn, rand


def MCStockPrices(S0, sigma, rateCurve, t, samples, integrator):
    '''
    :param S0: is the stock prices at time t0.
    :param sigma: is the constant volatility.
    :param rateCurve: is an InterestRateCurve stored as a numpy array.
    :param t: is an array of fixing times ti; i = 1 : : :N to simulate to.
    :param samples: is an array of uniform random samples to use. The
                    length of samples should be N M where N is the number of
                   fixing times and M is the number of paths.
    :param integrator: controls how the samples are generated according to the following value list
            'standard', where the paths are generated by using the
            solution of the Black-Scholes SDE step-by-step
            'euler', to use Euler-method integration of the Black-
            Scholes SDE
            'milstein', to use Milstein-method integration of the Black-
            Scholes SDE
    :return: a numpy array of simulated stock prices having the same dimensions as samples.
    '''
    M, N = np.shape(samples)
    stock_path = np.array((M, N))
    # standard
    if(integrator == 'standard'):
        for m in np.shape(samples, 1):
            for n in len(t):
                if (n == 0):
                    stock_path[n, m] = S0 * exp(
                        (rateCurve - 0.5 * sigma ** 2) * t[n] + sigma * sqrt(t[n]) * samples[n, m])
                stock_path[n, m] = stock_path[n - 1, m] * exp(
                    (rateCurve - 0.5 * sigma ** 2) * (t[n] - t[n - 1]) + sigma * sqrt((t[n] - t[n - 1])) * samples[
                        n, m])

    # euler
    if(integrator == 'euler'):
        for m in np.shape(samples, 1):
            for n in len(t):
                if (n == 0):
                    stock_path[n, m] = S0 * (1.0 + rateCurve * t[n] + sigma * sqrt(t[n]) * samples[n, m])
                stock_path[n, m] = stock_path[n - 1, m] * (
                            1.0 + rateCurve * t[n] + sigma * sqrt((t[n] - t[n - 1])) * samples[n, m])

    # milstein
    if(integrator == 'milstein'):
        for m in np.shape(samples, 1):
            for n in len(t):
                if (n == 0):
                    stock_path[n, m] = S0 * (1.0 + rateCurve * t[n] + sigma * sqrt((t[n])) * samples[n, m]
                                             + sigma ** 2 * (samples[n, m] ** 2 - 1) * t[n] / 2.0)
                stock_path[n, m] = stock_path[n - 1, m] * (
                            1.0 + rateCurve * t[n] + sigma * sqrt((t[n] - t[n - 1])) * samples[n, m]
                            + sigma ** 2 * (samples[n, m] ** 2 - 1) * (t[n] - t[n - 1]) / 2.0)

    return stock_path


